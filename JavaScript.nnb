{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "## Notas de clase\n\nPara ejecutar este cuaderno de ejemplo, puedes revisar: [Notebooks for Python and Javascript](https://codestax.medium.com/notebooks-for-python-and-javascript-aefbb5040428), esta hecho  con el objetivo de presentar el codigo fuente realizado y algunas anotaciones de temas complejos."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Exportaciones predeterminadas**"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const getFoo = function () {  \n    return 'C8288';  \n};  \n\nexport default getFoo; \n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                " Se define una función anónima que retorna la cadena 'C8288', y se almacena en la constante getFoo. Luego, se exporta esta constante como la exportación predeterminada del módulo usando export default. Solo puede haber una exportación predeterminada por archivo."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const obtenerManzana = function () {  \n    return 'manzana';  \n};  \n\nexport default obtenerManzana; \n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Exportaciones nombradas**"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "export const getFooBar = function () {  \n    return 'fq bar';  \n};  \n\nconst getBar = function () {  \n    return 'bar';  \n};  \n\nconst getBaz = function () {  \n    return 'baz';  \n};  \n\nexport {getBar, getBaz}; \n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "En este ejemplo, la función getFooBar es definida y exportada inmediatamente como una exportación nombrada. Luego, se definen otras dos funciones, getBar y getBaz, y se exportan juntas usando una sola declaración export con llaves ({}), lo que permite exportar múltiples elementos a la vez."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "export const obtenerFruta = function () {  \n    return 'manzana pera';  \n};  \n\nconst obtenerPera = function () {  \n    return 'pera';  \n};  \n\nconst obtenerUva = function () {  \n    return 'uva';  \n};  \n\nexport {obtenerPera, obtenerUva}; \n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Apunte:**  Las exportaciones predeterminadas se usan para exportar un solo valor o entidad por archivo, mientras que las exportaciones nombradas permiten exportar múltiples valores o entidades."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Cuando importas módulos en ES.Next, la sintaxis que usas depende del tipo de exportación que se hizo en el archivo del módulo. \n\n##### 1. **Importando exportaciones predeterminadas:**\n\nLa importación de una exportación predeterminada no requiere llaves `{}`. Puedes importar el módulo con un nombre local de tu elección. Aquí tienes el ejemplo corregido y algunos adicionales:\n\n  ```javascript\n  import getFoo from \"./default.js\"; \n  ```\n\n- En este caso, `getFoo` es la exportación predeterminada del archivo `default.js`. Se importa sin usar llaves y puedes darle cualquier nombre al importarlo.\n\n  ```javascript\n  import obtenerManzana from \"./fruta.js\";\n  ```\n\n  Aquí, `obtenerManzana` es la exportación predeterminada del archivo `fruta.js`. Nuevamente, no se usan llaves, y el nombre `obtenerManzana` puede ser cualquier nombre que elijas.\n\n##### 2. **Importando exportaciones nombradas:**\n\nPara las exportaciones nombradas, debes usar llaves `{}` y especificar el nombre exacto de las entidades que deseas importar. Si deseas renombrar una función o variable importada, puedes hacerlo usando `as`.\n\n\n  ```javascript\n  import {getFooBar, getBar, getBaz} from \"./named.js\"; \n  ```\n\n- Este código importa tres funciones (`getFooBar`, `getBar`, `getBaz`) del archivo `named.js`. Estas funciones se importan usando sus nombres originales y deben estar dentro de llaves `{}`.\n\n\n  - **Importando y renombrando:**\n    ```javascript\n    import {getFooBar as obtenerFruta, getBar as obtenerPera, getBaz as obtenerUva} from \"./fruta.js\"; \n    ```\n\n    Aquí, las funciones `getFooBar`, `getBar`, y `getBaz` se importan y se les asignan nuevos nombres (`obtenerFruta`, `obtenerPera`, `obtenerUva`) localmente en el archivo actual.\n\n  - **Importando solo algunos módulos:**\n    ```javascript\n    import {getFooBar, getBaz} from \"./fruta.js\";\n    ```\n\n    En este caso, solo se importan dos funciones (`getFooBar` y `getBaz`) desde el archivo `fruta.js`, y se omite `getBar`.\n\n##### 3. **Importación combinada:**\n\nPuedes combinar la importación de una exportación predeterminada y exportaciones nombradas en una sola línea:\n\n- **Ejemplo:**\n  ```javascript\n  import obtenerManzana, {getBar as obtenerPera, getBaz as obtenerUva} from \"./fruta.js\"; \n  ```\n\n  Este código importa la exportación predeterminada `obtenerManzana` y las exportaciones nombradas `getBar` y `getBaz`, renombradas como `obtenerPera` y `obtenerUva`, respectivamente.\n\n##### 4. **Importando todo el módulo:**\n\nSi deseas importar todo el contenido de un módulo bajo un solo objeto, puedes hacerlo usando el asterisco `*` y un alias:\n\n- **Ejemplo:**\n  ```javascript\n  import * as frutas from \"./fruta.js\";\n  ```\n\n  Ahora, todo lo que se exporta desde `fruta.js` está disponible bajo el objeto `frutas`. Puedes acceder a las funciones como `frutas.getFooBar`, `frutas.getBar`, y `frutas.getBaz`.\n\nEstos ejemplos muestran cómo puedes trabajar con las diferentes formas de importación de módulos en JavaScript ES.Next, permitiéndote organizar y reutilizar tu código de manera efectiva."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Declaración de variables**\n\n1. Alcance Global\nLas variables declaradas en el alcance global están disponibles en todo el programa, sin importar dónde se utilicen."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Variable global\nvar globalVar = \"Soy global\";\n\nfunction checkGlobal() {\n    console.log(globalVar); // Puede acceder a globalVar porque es global\n}\n\ncheckGlobal(); // Imprime: Soy global\nconsole.log(globalVar); // Imprime: Soy global\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Aquí, globalVar es una variable global porque se declara fuera de cualquier función, módulo o bloque. Es accesible tanto dentro de la función checkGlobal como fuera de ella, en cualquier parte del programa."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "2. Alcance de módulo\n\nEl alcance del módulo se refiere a variables y funciones que están disponibles solo dentro del módulo (archivo) en el que se definen."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// archivo: module1.js\n\n// Variable de módulo\nlet moduleVar = \"Estoy en el módulo 1\";\n\nexport function checkModule() {\n    console.log(moduleVar); // Puede acceder a moduleVar porque está en el mismo módulo\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// archivo: module2.js\n\nimport { checkModule } from './module1.js';\n\ncheckModule(); // Imprime: Estoy en el módulo 1\nconsole.log(moduleVar); // Error: moduleVar is not defined, porque moduleVar no está en el alcance de este módulo\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "La variable moduleVar está disponible solo dentro de module1.js. Aunque la función checkModule puede acceder a moduleVar dentro del mismo módulo, moduleVar no es accesible en module2.js."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "3. Alcance de Función\nLas variables definidas dentro de una función tienen un alcance de función, lo que significa que son accesibles solo dentro de esa función."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function checkFunctionScope() {\n    var functionVar = \"Estoy dentro de una función\";\n    console.log(functionVar); // Imprime: Estoy dentro de una función\n}\n\ncheckFunctionScope();\nconsole.log(functionVar); // Error: functionVar is not defined, porque está fuera del alcance de la función\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "functionVar solo está disponible dentro de checkFunctionScope. Al intentar acceder a functionVar fuera de la función, se genera un error porque no existe fuera del alcance de la función.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "4. Alcance de bloque\n\nLas variables declaradas con let o const dentro de un bloque {} tienen alcance de bloque, lo que significa que solo son accesibles dentro de ese bloque específico."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "if (true) {\n    let blockVar = \"Estoy dentro de un bloque\";\n    console.log(blockVar); // Imprime: Estoy dentro de un bloque\n}\n\nconsole.log(blockVar); // Error: blockVar is not defined, porque está fuera del alcance del bloque\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "blockVar se define dentro de un bloque if, por lo que solo es accesible dentro de ese bloque. Al intentar acceder a blockVar fuera de ese bloque, se genera un error porque está fuera de su alcance.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "5. Combinación de alcances\n\nUn alcance puede contener múltiples alcances secundarios. Por ejemplo, un alcance de función puede contener varios alcances de bloque.\n\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function checkScopes() {\n    var functionVar = \"Estoy en el alcance de función\";\n\n    if (true) {\n        let blockVar = \"Estoy en el alcance de bloque\";\n        console.log(functionVar); // Imprime: Estoy en el alcance de función\n        console.log(blockVar); // Imprime: Estoy en el alcance de bloque\n    }\n\n    console.log(blockVar); // Error: blockVar is not defined, fuera del alcance del bloque\n}\n\ncheckScopes();\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                " functionVar es accesible dentro del bloque if porque el alcance de función contiene al alcance de bloque. Sin embargo, blockVar no es accesible fuera del bloque if porque su alcance está limitado a ese bloque específico."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Variable hoisted**\nEn JavaScript, cuando declaras variables con la palabra clave `var`, estas variables son \"izadas\" (hoisted). Esto significa que el entorno de ejecución de JavaScript `mueve` la declaración de la variable al principio de su alcance, antes de que cualquier otro código sea ejecutado. Por lo tanto, puedes utilizar una variable declarada con `var` antes de que su declaración aparezca en el código.\n\nDijimos en clase que cuando el entorno de ejecución de JavaScript comienza a interpretar el código, realiza una primera pasada donde identifica todas las declaraciones de variables (var) y funciones. Durante esta pasada, esas declaraciones son \"movidas\" al inicio de su contexto de alcance correspondiente (función, bloque, o global), pero sin sus valores asignados.\n\nEsto significa que puedes usar una variable declarada con `var` antes de su declaración en el código, porque JavaScript la ha \"movido\" al principio de su alcance, aunque no haya sido asignado un valor todavía."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "console.log(a); // ¿Qué crees que sucede aquí?\nvar a = 5;"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Lo que realmente ocurre internamente:\n\nEl entorno de ejecución de JavaScript interpreta este código como si estuviera escrito así:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "var a; // La declaración es izada al inicio de su alcance\nconsole.log(a); // Aquí a es undefined, porque la asignación aún no ha ocurrido\na = 5; // Asignación del valor a a"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- La declaración `var a`; es movida al principio del alcance (en este caso, el alcance global), pero su valor aún no se ha asignado. Esto significa que `a` existe y está definida, pero su valor es undefined en el momento en que console.log(a); se ejecuta.\n- Cuando console.log(a); se ejecuta, `a` ya ha sido declarada, pero no tiene un valor asignado aún, por lo que undefined se imprime en la consola.\n- Finalmente, se ejecuta la línea `a = 5`;, asignando el valor 5 a `a`.\n\nEste comportamiento es específico de variables declaradas con `var`. Las variables declaradas con `let` y `const` no están accesibles antes de la línea en la que se declaran debido a una característica llamada \"zona muerta temporal\" (temporal dead zone), lo que genera un error si intentas usarlas antes de su declaración."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**La palabra clave let**"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let globalVar = \"global\";\n\nfunction scope() {\n    let a = \"1\";\n\n    if (true) {\n        let bar = \"2\";\n    }\n\n    console.log(globalVar); // Imprime: \"global\"\n    console.log(window.globalVar); // Imprime: undefined\n    console.log(a); // Imprime: \"1\"\n    console.log(bar); // Error: Uncaught ReferenceError: bar is not defined\n}\n\nscope();\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- let globalVar: Esta variable se declara en el alcance global pero no se agrega al objeto window, lo que significa que window.globalVar será undefined.\n- let a: Esta variable se declara dentro de la función scope y solo es accesible dentro de esa función. Por lo tanto, console.log(a); imprime \"1\".\n- let bar: Esta variable se declara dentro de un bloque if, y su alcance está limitado a ese bloque. Como resultado, intentar acceder a bar fuera del bloque, como se hace en console.log(bar);, generará un error de referencia (ReferenceError) porque bar no está definida en ese contexto.\n- window.globalVar: Como globalVar se declaró con let, no se convierte en una propiedad del objeto global window, lo que significa que window.globalVar es undefined."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let globalVar = \"global\";\n\nfunction scope() { \n    let f = 1; \n    if (true) { \n        let bar = \"2\"; \n        console.log(bar); // Puedes acceder a 'bar' aquí dentro\n    } \n    console.log(globalVar); \n\n    // En lugar de window, utiliza global en Node.js\n    if (typeof global !== \"undefined\") {\n        console.log(global.globalVar); \n    }\n\n    console.log(f); \n\n    // Aquí fuera, 'bar' no es accesible, así que comentamos o eliminamos esta línea\n    // console.log(bar); // Esto generará un error porque 'bar' no está en el alcance\n}\n\nscope();\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function loopExample() {\n    for (let i = 0; i < 3; i++) {\n        console.log(i); // Imprime: 0, 1, 2\n    }\n\n    console.log(i); // Error: Uncaught ReferenceError: i is not defined\n}\n\nloopExample();\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Aquí, `i` está limitado al alcance del bloque for, lo que significa que solo es accesible dentro del ciclo. Intentar acceder a `i` fuera del ciclo generará un error porque `i` no está definida fuera del alcance del bloque."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function temporalDeadZoneExample() {\n    console.log(a); // Error: Uncaught ReferenceError: a is not defined\n    let a = 10;\n}\n\ntemporalDeadZoneExample();"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                " Aunque la variable `a` es izada técnicamente, no se puede acceder a ella antes de su declaración debido a la \"Zona Muerta Temporal\" (TDZ). Esto provoca un error de referencia cuando intentas usar a antes de su declaración con let."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function letVsVarExample() {\n    if (true) {\n        let x = 5;\n        var y = 10;\n    }\n\n    console.log(x); // Error: Uncaught ReferenceError: x is not defined\n    console.log(y); // Imprime: 10\n}\n\nletVsVarExample();"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "`x` es una variable de alcance de bloque y no está disponible fuera del bloque if, mientras que `y` es una variable declarada con `var`, que tiene un alcance de función (o global si está fuera de cualquier función), lo que permite que y sea accesible fuera del bloque if."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Datos como constantes**\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const primitiveDataType = 1;\n\ntry {\n    primitiveDataType = 2;\n} catch (err) {\n    console.log(err); // Error: TypeError: Assignment to constant variable.\n}\n\nconst nonPrimitiveDataType = [];\n\nnonPrimitiveDataType.push(1);\nconsole.log(nonPrimitiveDataType); // Imprime: [1]\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Si intentaras reasignar una constante que contiene un objeto, obtendrías un error similar al anterior:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const obj = { name: \"Kapu\" };\n\ntry {\n    obj = { name: \"Mota\" };\n} catch (err) {\n    console.log(err); // Error: TypeError: Assignment to constant variable.\n}\n\n// Sin embargo, puedes modificar las propiedades del objeto:\nobj.name = \"Mota\";\nconsole.log(obj); // Imprime: { name: \"Mota\" }\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Funciones flechas**\n\nLas funciones flecha, introducidas en ECMAScript 6 (ES6), son una forma más concisa de escribir funciones en JavaScript. Son especialmente útiles cuando se quieren definir funciones de manera rápida y en situaciones donde se utilizan como callbacks o funciones anónimas. \n\n```javascript\nconst nombreFuncion = (parametros) => {\n    // Cuerpo de la función\n    return resultado;\n};\n\n```\nSin embargo, si la función tiene solo un parámetro, puedes omitir los paréntesis, y si el cuerpo de la función tiene una sola expresión, puedes omitir las llaves {} y la palabra clave return. En este caso, el resultado de la expresión se devuelve automáticamente."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const traditional = function (x) {\n    return x * x;\n};\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const conciseBody = x => x * x;"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const sum = (a, b) => {\n    return a + b;\n};\n\n// O de manera aún más concisa:\nconst sumConcise = (a, b) => a + b;\n\nconsole.log(sum(2, 3)); // Imprime: 5\nconsole.log(sumConcise(2, 3)); // Imprime: 5\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Aquí, sum y sumConcise son funciones flecha que aceptan dos parámetros (a y b) y devuelven su suma. La versión concisa es posible porque el cuerpo de la función es una sola expresión."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const greet = () => \"Hello, world!\";\n\nconsole.log(greet()); // Imprime: Hello, world!\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Cuando una función flecha no tiene parámetros, los paréntesis vacíos () son obligatorios. En este caso, la función greet devuelve una cadena fija \"Hello, world!\"."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "//Funciones arrow y callbaks.\nconst numbers = [1, 2, 3, 4, 5];\n\nconst doubled = numbers.map(n => n * 2);\n\nconsole.log(doubled); // Imprime: [2, 4, 6, 8, 10]\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Las funciones flecha son especialmente útiles como `callbacks`, donde se necesita pasar una función como argumento a otra función. \n\nEn este ejemplo, la función flecha n => n * 2 se pasa como callback al método map de un array. Cada elemento del array numbers se multiplica por 2, y el resultado se almacena en el nuevo array doubled."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Alcance léxico**\n\nUna de las características más importantes y menos obvias de las funciones flecha es su manejo del contexto `this`. A diferencia de las funciones tradicionales, las funciones flecha no tienen su propio `this`. En su lugar, heredan el `this` del contexto en el que fueron definidas, lo que las hace más predecibles en situaciones donde se usan como callbacks."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function Person() {\n    this.age = 0;\n\n    setInterval(() => {\n        this.age++;\n        console.log(this.age); // Imprime: 1, 2, 3, ...\n    }, 1000);\n}\n\nconst person = new Person();\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "En este ejemplo, la función flecha usada en `setInterval` hereda el `this` de la función `Person`. Esto significa que dentro de la función flecha, `this` se refiere al objeto `person`, lo que permite que `this.age` se incremente correctamente. Si hubiéramos usado una función tradicional, `this` podría haber sido redefinido y no se habría comportado como se esperaba."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "this.scope = \"alcance léxico\"; // ❶ Definición en el contexto global\n\nconst scopeOf = {\n    scope: \"alcance definidor\", // ❷ Definición en el objeto `scopeOf`\n\n    traditional: function () {\n        return this.scope; // ❸ `this` se refiere al objeto que llama a la función\n    },\n\n    arrow: () => {\n        return this.scope; // `this` se refiere al contexto léxico, no al objeto\n    },\n};\n\nconsole.log(scopeOf.traditional()); // Imprime: \"alcance definidor\"\nconsole.log(scopeOf.arrow()); // Imprime: \"alcance léxico\"\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- Alcance léxico (❶): La variable `this.scope` se define en el contexto global (o léxico). Esto significa que `this` en cualquier función flecha definida en este contexto se referirá a `this.scope = \"alcance léxico\";` porque las funciones flecha no redefinen `this`.\n- Alcance definidor (❷): Dentro del objeto `scopeOf`, hay una propiedad scope definida con el valor \"alcance definidor\". Este es el valor que una función tradicional dentro de este objeto referenciará cuando se invoque.\n- Función tradicional (❸): La función traditional es una función regular. Cuando `scopeOf.traditional()` es llamada, `this` se refiere al objeto `scopeOf`, por lo que devuelve \"alcance definidor\".\n- Función flecha: La función `arrow` es una función flecha. Cuando se ejecuta `scopeOf.arrow()`, `this` no se refiere al objeto `scopeOf`, sino al `this` del contexto donde la función fue definida. Dado que la función flecha hereda `this` del contexto global (o léxico), devuelve \"alcance léxico\".\n\nConceptos clave:\n\n- Alcance léxico: En funciones flecha, `this` es determinado por el lugar donde se define la función, no donde se invoca. Esto significa que `this` en una función flecha siempre se refiere al mismo valor que en el contexto en que la función fue definida.\n- Alcance definidor: En funciones tradicionales, `this` es dinámico y se refiere al objeto que llama a la función. Si llamas a la función desde un objeto, `this` apunta a ese objeto."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function Timer() {\n    this.seconds = 0;\n\n    setInterval(function() {\n        this.seconds++;\n        console.log(this.seconds); // `this` aquí se refiere al objeto global o a `undefined` en modo estricto\n    }, 1000);\n}\n\nconst timer = new Timer(); // Esto no funciona como se espera\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "En este ejemplo, `this` dentro de la función pasada a `setInterval` se refiere al objeto global (window en navegadores) en lugar de al objeto `Timer`, lo que puede causar errores inesperados.\n\nPara solucionar esto, puedes usar una función flecha:\n\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function Timer() {\n    this.seconds = 0;\n\n    setInterval(() => {\n        this.seconds++;\n        console.log(this.seconds); // `this` aquí se refiere al objeto `Timer`\n    }, 1000);\n}\n\nconst timer = new Timer(); // Esto funciona correctamente\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Funciones como ciudadanos de primera clase**\n\nCiudadanos de primera clase significa que en JavaScript, las funciones pueden ser tratadas como cualquier otro valor: pueden ser asignadas a variables, pasadas como argumentos a otras funciones, y devueltas por funciones. Esto es lo que permite el uso de funciones como callbacks en métodos como filter."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let numbers = [-2, -1, 0, 1, 2];\n\nlet traditional = numbers.filter(function(num) {\n    return num >= 0;\n});\n\nlet arrow = numbers.filter(num => num >= 0);\n\nconsole.log(traditional); // Imprime: [0, 1, 2]\nconsole.log(arrow); // Imprime: [0, 1, 2]\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Cadenas**\n\nLiterales de plantilla no etiquetado"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let a = 1; \nlet b = 2; \nlet string = `${a} + ${b} = ${a + b}`; \nconsole.log(string);\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let name = \"Alice\"; \nlet age = 30; \nlet greeting = `Hola mi nombre es ${name} y tengo ${age} años.`; \nconsole.log(greeting);\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let multiLine = `This is a string \nthat spans across \nmultiple lines.`;\n\nconsole.log(multiLine);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Literales de plantilla etiquetado."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function simpleTag(strings, ...values) { \n    console.log(strings);  // [\"Hello, \", \" is \", \" years old.\"] \n    console.log(values);   // [\"Kapu\", 30] \n    return strings.join('') + values.join(''); \n} \n\nlet name = \"Kapu\"; \nlet age = 30; \n\nlet result = simpleTag`Hello, ${name} is ${age} years old.`; \nconsole.log(result); \n \n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "La función `simpleTag` recibe una matriz de partes de cadena (strings) y una matriz de valores interpolados (values), que luego son combinados y retornados."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function simpleTag(strings, ...values) { \n    let result = strings.reduce((acc, str, i) => {\n        return acc + str + (values[i] !== undefined ? values[i] : '');\n    }, '');\n    return result;\n} \n\nlet name = \"Kapu\"; \nlet age = 30; \n\nlet result = simpleTag`Hello, ${name} is ${age} years old.`; \nconsole.log(result);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                " Utilizamos `reduce` para construir la cadena final. Por cada parte de la cadena en strings, se añade el correspondiente valor interpolado de values, si existe."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function upperCaseTag(strings, ...values) { \n    // Convierte cada cadena a mayúsculas \n    let result = strings.map(str => str.toUpperCase()); \n    // Concatena el literal de plantilla con los valores interpolados \n    return result.reduce((acc, str, i) => acc + str + (values[i] || ''), '');\n} \n\nlet name = \"Kapu\"; \nlet city = \"Wonderland\"; \n\nlet message = upperCaseTag`Hello, ${name} from ${city}!`; \n\nconsole.log(message);\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function formatCurrency(strings, ...values) { \n    // Convierte valores numéricos a formato de moneda \n    return strings.reduce((result, string, i) => { \n        let value = values[i]; \n        if (typeof value === 'number') { \n            value = `$${value.toFixed(2)}`; \n        } \n        return result + string + (value || ''); \n    }, ''); \n} \n\nlet price = 25.99; \nlet discount = 5; \n\nlet receipt = formatCurrency`El precio total es ${price} con un descuento de ${discount}.`; \n\nconsole.log(receipt);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Programación asincrónica en JavaScript**\n\nQué son las tareas no bloqueantes? \n\nLas tareas no bloqueantes son operaciones que pueden iniciarse y, en lugar de esperar a que se completen, permiten que el programa continúe ejecutando otras operaciones. Una vez que la tarea no bloqueante está completa, el programa vuelve a procesar su resultado. Este enfoque es clave en la programación asincrónica en JavaScript. \n\nCuando ejecutas un script en JavaScript, cada línea de código se ejecuta secuencialmente. Sin embargo, si una tarea tarda mucho tiempo (como una solicitud de red o una lectura de archivo), esto podría bloquear el hilo principal, haciendo que tu aplicación no responda. Para evitar esto, JavaScript permite que ciertas operaciones se realicen de manera asincrónica, liberando el hilo principal para que pueda seguir ejecutando otras tareas mientras se espera el resultado. \n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "console.log(\"Inicio de la solicitud\"); \n\nfetch(\"https://api.example.com/data\") \n\n    .then(response => response.json()) \n\n    .then(data => { \n\n        console.log(\"Datos recibidos:\", data); \n\n    }); \n\nconsole.log(\"Solicitud enviada, esperando respuesta...\"); "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "El error que estás viendo (ENOTFOUND api.example.com) indica que la dirección api.example.com no se pudo resolver porque no es un dominio válido o accesible desde tu entorno. La función fetch intenta hacer una solicitud HTTP a ese dominio, pero no puede encontrarlo."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "console.log(\"Inicio de la solicitud\");\n\nfetch(\"https://jsonplaceholder.typicode.com/posts/1\")\n    .then(response => response.json())\n    .then(data => {\n        console.log(\"Datos recibidos:\", data);\n    });\n\nconsole.log(\"Solicitud enviada, esperando respuesta...\");\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "En este ejemplo: \n\n1. Inicio de la solicitud: Se imprime inmediatamente. \n2. Solicitud enviada, esperando respuesta...: Se imprime inmediatamente después de que se envía la solicitud, sin esperar a que se complete la solicitud de la API. \n3. Datos recibidos: Este mensaje se imprime solo después de que los datos se han recibido y procesado, en un momento posterior. "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "console.log(\"Inicio\"); \n\nsetTimeout(() => { \n\n    console.log(\"Esta tarea se ejecuta después de 2 segundos\"); \n\n}, 2000); \n\nconsole.log(\"Fin\"); "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "En este ejemplo: \n\n- Inicio y Fin se imprimen inmediatamente. \n- La tarea dentro de setTimeout se ejecuta después de 2 segundos, permitiendo que el hilo principal continúe ejecutando otras operaciones mientras espera. "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "console.log(\"Iniciando el intervalo\"); \nlet counter = 0;\n\nfunction executeInterval() {\n    counter++;\n    console.log(`Intervalo ejecutado: ${counter}`);\n    if (counter < 5) {\n        setTimeout(executeInterval, 1000); // Llama a sí mismo después de 1 segundo\n    }\n}\n\nsetTimeout(executeInterval, 1000); // Comienza el \"intervalo\" después de 1 segundo\nconsole.log(\"Intervalo configurado\");\n\n// Output: \n\n// Iniciando el intervalo \n\n// Intervalo configurado \n\n// Intervalo ejecutado: 1 \n\n// Intervalo ejecutado: 2 \n\n// Intervalo ejecutado: 3 \n\n// Intervalo ejecutado: 4 \n\n// Intervalo ejecutado: 5 "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "En este ejemplo: \n\n- El intervalo se configura y ejecuta cada segundo. \n- Mientras tanto, otras operaciones (como console.log(\"Intervalo configurado\");) continúan ejecutándose sin esperar a que el intervalo termine. "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Callbacks**\n\nEn JavaScript, un *callback* es una función que se pasa como argumento a otra función y que se ejecuta después de que se completa alguna operación dentro de la función en la que fue pasada. \n\nCuando JavaScript necesita realizar una tarea que podría tardar un tiempo en completarse (como leer un archivo, realizar una solicitud HTTP, o establecer un temporizador), puede usar un callback para indicar qué hacer una vez que se complete la tarea. En lugar de esperar a que la tarea termine (lo que bloquearía el hilo principal), JavaScript sigue ejecutando otras tareas y, una vez que la operación asincrónica está completa, ejecuta la función callback."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function getData(callback) { \n    console.log(\"Iniciando solicitud de datos...\"); \n    setTimeout(() => { \n        console.log(\"Datos recibidos\"); \n        const data = { id: 1, name: \"Producto\" }; \n        callback(data); \n    }, 2000); \n} \nfunction processData(data) { \n    console.log(\"Procesando datos:\", data); \n\n} \n\ngetData(processData); "
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Iniciando solicitud de datos...",
                                "Procesando datos: { id: 1, name: 'Producto' }",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Explicación: \n\n1. getData recibe una función callback como argumento. \n2. Se simula una operación asincrónica con setTimeout. \n3. Después de 2 segundos, se obtiene \"Datos recibidos\" y se ejecuta el callback (processData), pasando los datos obtenidos como argumento. \n4. processData es llamada, y los datos son procesados (en este caso, se imprimen en la consola). "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Callback anidado**"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function primeraTarea(callback) { \n    setTimeout(() => { \n        console.log(\"Primera tarea completada\"); \n        callback(\"datos de la primera tarea\"); \n    }, 1000); \n\n} \n\nfunction segundaTarea(data, callback) { \n    setTimeout(() => { \n        console.log(\"Segunda tarea completada usando\", data); \n        callback(\"datos de la segunda tarea\"); \n\n    }, 1000); \n\n} \n\nfunction terceraTarea(data, callback) { \n    setTimeout(() => { \n        console.log(\"Tercera tarea completada usando\", data); \n        callback(\"datos de la tercera tarea\"); \n    }, 1000); \n\n} \n\nprimeraTarea((data1) => { \n\n    segundaTarea(data1, (data2) => { \n\n        terceraTarea(data2, (data3) => { \n            console.log(\"Todas las tareas completadas con:\", data3); \n        }); \n    }); \n}); "
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Primera tarea completada",
                                "Segunda tarea completada usando datos de la primera tarea",
                                "Tercera tarea completada usando datos de la segunda tarea",
                                "Todas las tareas completadas con: datos de la tercera tarea",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "function primeraTarea(callback) { \n    setTimeout(() => { \n        console.log(\"Primera tarea completada\"); \n        callback(\"datos de la primera tarea\"); \n    }, 1000); \n\n} \n\nfunction segundaTarea(data, callback) { \n    setTimeout(() => { \n        console.log(\"Segunda tarea completada usando\", data); \n        callback(\"datos de la segunda tarea\"); \n\n    }, 1000); \n\n} \n\nfunction terceraTarea(data, callback) { \n    setTimeout(() => { \n        console.log(\"Tercera tarea completada usando\", data); \n        callback(\"datos de la tercera tarea\"); \n    }, 1000); \n\n} \nfunction cuartaTarea(data, callback) {\n    setTimeout(()=> {\n        console.log(\"Cuarta tarea completada usando\", data);\n        callback(\"datos de la cuarta tarea\");\n\n    },1000)\n}\nprimeraTarea((data1) => { \n\n    segundaTarea(data1, (data2) => { \n\n        terceraTarea(data2, (data3) => {\n            \n            cuartaTarea(data3, (data4) => { \n                console.log(\"Todas las tareas completadas con:\", data4); \n            });\n        }); \n    }); \n}); "
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Primera tarea completada",
                                "Segunda tarea completada usando datos de la primera tarea",
                                "Tercera tarea completada usando datos de la segunda tarea",
                                "Cuarta tarea completada usando datos de la tercera tarea",
                                "Todas las tareas completadas con: datos de la cuarta tarea",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "- primeraTarea, segundaTarea, y terceraTarea son funciones asincrónicas que dependen unas de otras. \n- Cada función recibe un callback que se ejecuta una vez que la tarea está completa. \n- Al finalizar todas las tareas, la consola imprimirá: \"Todas las tareas completadas con: datos de la tercera tarea\". "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Infierno de callbacks**"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Código JavaScript completo en un archivo\ndoSomething(function(result) { \n    doSomethingElse(result, function(newResult) { \n        doAnotherThing(newResult, function(finalResult) { \n            doFinalThing(finalResult, function() { \n                console.log(\"Primera parte completada\");      \n                // Segunda parte anidada aún más profundamente\n                doSomethingMore(function(extraResult) {\n                    doEvenMore(extraResult, function(evenMoreResult) {\n                        finishItOff(evenMoreResult, function() {\n                            console.log(\"Todo completado finalmente\");\n                        });\n                    });\n                });\n            }); \n        }); \n    }); \n});"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "ReferenceError",
                                "message": "doSomething is not defined",
                                "stack": "    at <Cell 93> [2, 11]\n    at <Cell 93> [19, 46]\n    at Script.runInContext (node:vm:148:12)\n    at Script.runInNewContext (node:vm:153:17)\n    at Object.runInNewContext (node:vm:309:38)\n    at C (/home/alumnos/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:113345)\n    at t.execCode (/home/alumnos/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:114312)\n    at k.<anonymous> (/home/alumnos/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:142156)\n    at k.emit (node:events:519:28)\n    at k.emit (node:domain:488:12)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "%%writefile hellcallBack.js\n\nfunction doSomething(callback) {\n    callback(\"Resultado de doSomething\");\n}\n\nfunction doSomethingElse(result, callback) {\n    callback(result + \" -> Resultado de doSomethingElse\");\n}\n\nfunction doAnotherThing(result, callback) {\n    callback(result + \" -> Resultado de doAnotherThing\");\n}\n\nfunction doFinalThing(result, callback) {\n    callback(result + \" -> Resultado de doFinalThing\");\n}\n\nfunction doSomethingMore(callback) {\n    callback(\"Resultado de doSomethingMore\");\n}\n\nfunction doEvenMore(result, callback) {\n    callback(result + \" -> Resultado de doEvenMore\");\n}\n\nfunction finishItOff(result, callback) {\n    callback(result + \" -> Todo completado\");\n}\n\ndoSomething(function(result) {\n    doSomethingElse(result, function(newResult) {\n        doAnotherThing(newResult, function(finalResult) {\n            doFinalThing(finalResult, function() {\n                console.log(\"Primera parte completada\");\n                \n                doSomethingMore(function(extraResult) {\n                    doEvenMore(extraResult, function(evenMoreResult) {\n                        finishItOff(evenMoreResult, function() {\n                            console.log(\"Todo completado finalmente\");\n                        });\n                    });\n                });\n            });\n        });\n    });\n});\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "Error",
                                "message": "Failed to generate code object, \nfunction doSomething(callback) {\n ^\n\nUnexpected token ' '",
                                "stack": ""
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "**Promesas**\n\nLas promesas en JavaScript son un mecanismo para manejar operaciones asincrónicas de manera más limpia y manejable que con los callbacks tradicionales. Una promesa representa un valor que puede estar disponible ahora, en el futuro, o nunca, y proporciona una forma de encadenar acciones que dependen del resultado de esa operación asincrónica.\n\nEstado de la promesa:\n\n- Pendiente (Pending): La promesa se ha iniciado, pero aún no ha terminado.\n- Cumplida (Fulfilled): La operación se completó con éxito, y la promesa devuelve un valor.\n- Rechazada (Rejected): La operación falló, y la promesa devuelve un error.\n\nEncadenamiento:\n\n.then(): Se ejecuta cuando la promesa se resuelve con éxito. Puede encadenarse para manejar operaciones secuenciales.\n.catch(): Se ejecuta si la promesa se rechaza debido a un error.\n.finally(): Se ejecuta después de que la promesa se resuelva o se rechace, ideal para tareas de limpieza."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function ejemploPromesa() {\n    return new Promise((resolve, reject) => {\n        let exito = true; // Simula una operación exitosa\n\n        if (exito) {\n            resolve(\"La operación fue exitosa\");\n        } else {\n            reject(\"La operación falló\");\n        }\n    });\n}\n\nejemploPromesa()\n    .then((mensaje) => {\n        console.log(mensaje); // Imprime: La operación fue exitosa\n    })\n    .catch((error) => {\n        console.error(error); // Esto no se ejecuta en este caso\n    })\n    .finally(() => {\n        console.log(\"Operación completada\"); // Imprime: Operación completada\n    });\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "La operación fue exitosa",
                                "Operación completada",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "- new Promise: Se crea una nueva promesa que simula una operación que puede tener éxito o fallar.\n- resolve: Llama a esta función si la operación tiene éxito.\n- reject: Llama a esta función si la operación falla.\n- Encadenamiento: Se utilizan then, catch y finally para manejar los diferentes resultados de la promesa."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "import { error } from \"console\";\n\nPromise \n    .then(resultado => {\n        console.log(resultado);\n    })\n    .catch(error => {\n        console.log(error);\n    });"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                ""
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function fetchData(url) {\n    fetch(url)\n        .then((response) => {\n            if (!response.ok) {\n                throw new Error(\"Network response was not ok\");\n            }\n            return response.json();\n        })\n        .then((json) => {\n            console.log(\"Datos obtenidos:\", json);\n        })\n        .catch((error) => {\n            console.error(`Error: ${error.message}`);\n        })\n        .finally(() => {\n            console.log(\"Finalizó la operación de fetch.\");\n        });\n}\n\nfetchData(\"https://jsonplaceholder.typicode.com/posts/1\");\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Datos obtenidos: {",
                                "  userId: 1,",
                                "  id: 1,",
                                "  title: 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit',",
                                "  body: 'quia et suscipit\\n' +",
                                "    'suscipit recusandae consequuntur expedita et cum\\n' +",
                                "    'reprehenderit molestiae ut ut quas totam\\n' +",
                                "    'nostrum rerum est autem sunt rem eveniet architecto'",
                                "}",
                                "Finalizó la operación de fetch.",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "Ejemplo práctico usando la API fetch para obtener datos de una URL.\n\n- fetch(url): Hace una solicitud HTTP y devuelve una promesa.\n- Primer then: Verifica si la respuesta fue exitosa (código de estado HTTP 200-299). Si no lo fue, lanza un error.\n- Segundo then: Parsea la respuesta en formato JSON y la imprime en la consola.\n- catch: Captura cualquier error ocurrido durante la operación.\n- finally: Siempre se ejecuta, independientemente de si la promesa se resolvió o se rechazó, y se utiliza para realizar tareas de limpieza.\n\nRecuerda: una vez que tienes una promesa, puedes manejar su resultado o error utilizando los métodos then y catch.\n\n* then: Se utiliza para manejar el caso en que la promesa se resuelve (cumple).\n* catch: Se utiliza para manejar el caso en que la promesa se rechaza (falla)."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "promise\n    .then(result => {\n        console.log(result); // Se ejecuta si la promesa se resuelve\n    })\n    .catch(error => {\n        console.error(error); // Se ejecuta si la promesa se rechaza\n    });\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "ReferenceError",
                                "message": "promise is not defined",
                                "stack": "    at <Cell 101> [1, 7]\n    at <Cell 101> [10, 46]\n    at Script.runInContext (node:vm:148:12)\n    at Script.runInNewContext (node:vm:153:17)\n    at Object.runInNewContext (node:vm:309:38)\n    at C (/home/alumnos/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:113345)\n    at t.execCode (/home/alumnos/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:114312)\n    at k.<anonymous> (/home/alumnos/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:142156)\n    at k.emit (node:events:519:28)\n    at k.emit (node:domain:488:12)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "javascript",
            "source": [
                "function fetchData() {\n    return new Promise((resolve, reject) => {\n        console.log(\"Iniciando solicitud de datos...\");\n\n        setTimeout(() => {\n            let success = true; // Simula éxito o fracaso\n            if (success) {\n                resolve({ id: 1, name: \"Producto\" });\n            } else {\n                reject(\"Error: No se pudo obtener los datos.\");\n            }\n        }, 2000);\n    });\n}\n\nfetchData()\n    .then(data => {\n        console.log(\"Datos recibidos:\", data);\n        // Puedes retornar otra promesa para encadenar más .then()\n        return \"Proceso adicional con los datos\";\n    })\n    .then(message => {\n        console.log(message);\n    })\n    .catch(error => {\n        console.error(error);\n    });\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Iniciando solicitud de datos...",
                                "Datos recibidos: { id: 1, name: 'Producto' }",
                                "Proceso adicional con los datos",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "- fetchData es una función que retorna una promesa.\n- Dentro de la promesa, simulamos una operación asincrónica (como una solicitud de red) con setTimeout.\n- Si la operación es exitosa, llamamos a resolve con los datos recibidos.\n- Si ocurre un error, llamamos a reject con un mensaje de error.\n- En la cadena de then, manejamos los datos recibidos y podemos encadenar más operaciones si es necesario.\n- Si ocurre un error, catch manejará ese error."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function primerPaso() {\n    return new Promise((resolve) => {\n        console.log(\"Primer paso completado\");\n        resolve(\"Datos del primer paso\");\n    });\n}\n\nfunction segundoPaso(data) {\n    return new Promise((resolve) => {\n        console.log(\"Segundo paso completado con:\", data);\n        resolve(\"Datos del segundo paso\");\n    });\n}\n\nfunction tercerPaso(data) {\n    return new Promise((resolve) => {\n        console.log(\"Tercer paso completado con:\", data);\n        resolve(\"Datos del tercer paso\");\n    });\n}\n\nprimerPaso()\n    .then(result => segundoPaso(result))\n    .then(result => tercerPaso(result))\n    .then(result => {\n        console.log(\"Todos los pasos completados con:\", result);\n    })\n    .catch(error => {\n        console.error(\"Ocurrió un error:\", error);\n    });\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- primerPaso, segundoPaso, y tercerPaso son funciones que retornan promesas.\n- Las promesas se encadenan usando then para manejar los resultados de cada operación sucesiva.\n- catch maneja cualquier error que pueda ocurrir en cualquier parte de la cadena."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Promesas y asincronia en paralelo**"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let promise1 = new Promise((resolve) => setTimeout(() => resolve(\"Primera promesa\"), 1000));\nlet promise2 = new Promise((resolve) => setTimeout(() => resolve(\"Segunda promesa\"), 2000));\nlet promise3 = new Promise((resolve) => setTimeout(() => resolve(\"Tercera promesa\"), 3000));\n\nPromise.all([promise1, promise2, promise3])\n    .then(results => {\n        console.log(\"Todas las promesas completadas:\", results);\n    })\n    .catch(error => {\n        console.error(\"Ocurrió un error en alguna promesa:\", error);\n    });\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- Promise.all toma un arreglo de promesas y retorna una nueva promesa que se resuelve cuando todas las promesas en el arreglo se han completado.\n- El valor resultante es un arreglo con los resultados de cada promesa en el mismo orden en que fueron proporcionadas."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**async/await**\n\nSupongamos que queremos simular la obtención de datos de un servidor:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function getData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(\"Datos recibidos\");\n        }, 2000);\n    });\n}\n\nasync function fetchData() {\n    console.log(\"Iniciando solicitud...\");\n    const data = await getData();\n    console.log(data); // Se ejecuta después de que la promesa se resuelve\n    console.log(\"Solicitud completada.\");\n}\n\nfetchData();\n// Output:\n// Iniciando solicitud...\n// (2 segundos después)\n// Datos recibidos\n// Solicitud completada.\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- getData: Es una función que retorna una promesa que se resuelve después de 2 segundos.\n- fetchData: Es una función asincrónica (declarada con async). Dentro de ella, usamos await para esperar a que la promesa de getData se resuelva antes de continuar.\n- El código se ejecuta de manera que parece síncrono, aunque en realidad no lo es, lo que hace que sea más fácil de leer y entender."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Al usar `async/await`, puedes manejar errores de forma más sencilla utilizando bloques try/catch en lugar de catch() en promesas. Esto proporciona una manera más natural y fluida de manejar excepciones en código asincrónico."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "function getData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            const success = Math.random() > 0.5; // Simulamos éxito o fracaso aleatoriamente\n            if (success) {\n                resolve(\"Datos recibidos\");\n            } else {\n                reject(\"Error al obtener los datos\");\n            }\n        }, 2000);\n    });\n}\n\nasync function fetchData() {\n    try {\n        console.log(\"Iniciando solicitud...\");\n        const data = await getData();\n        console.log(data); // Se ejecuta si la promesa se resuelve\n    } catch (error) {\n        console.error(error); // Se ejecuta si la promesa se rechaza\n    } finally {\n        console.log(\"Solicitud completada.\"); // Siempre se ejecuta\n    }\n}\n\nfetchData();\n// Output (puede variar):\n// Iniciando solicitud...\n// (2 segundos después, si se resuelve)\n// Datos recibidos\n// Solicitud completada.\n// OR\n// Iniciando solicitud...\n// (2 segundos después, si falla)\n// Error al obtener los datos\n// Solicitud completada.\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "- try: Contiene el código que se espera que funcione correctamente, pero que puede lanzar excepciones.\n- catch: Captura cualquier error que ocurra dentro del bloque try y permite manejarlo.\n- finally: Se ejecuta después de try y catch, independientemente de si ocurrió un error o no, lo que es útil para realizar limpieza o tareas finales."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Encadenamiento de async/await\nasync function processData() {\n    try {\n        const step1 = await firstStep();\n        console.log(\"Paso 1:\", step1);\n\n        const step2 = await secondStep(step1);\n        console.log(\"Paso 2:\", step2);\n\n        const step3 = await thirdStep(step2);\n        console.log(\"Paso 3:\", step3);\n        \n        console.log(\"Todos los pasos completados.\");\n    } catch (error) {\n        console.error(\"Error en el proceso:\", error);\n    }\n}\n\nprocessData();\n// Output (puede variar):\n// Paso 1: Resultado del primer paso\n// Paso 2: Resultado del segundo paso\n// Paso 3: Resultado del tercer paso\n// Todos los pasos completados.\n"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "//Paralelismo con async/await y Promise.all\nasync function fetchMultipleData() {\n    const promise1 = getData1(); // Simula una solicitud de datos\n    const promise2 = getData2(); // Simula otra solicitud de datos\n\n    try {\n        const [data1, data2] = await Promise.all([promise1, promise2]);\n        console.log(\"Datos 1:\", data1);\n        console.log(\"Datos 2:\", data2);\n    } catch (error) {\n        console.error(\"Error al obtener datos:\", error);\n    }\n}\n\nfetchMultipleData();\n// Output (puede variar):\n// Datos 1: Resultado de la primera solicitud\n// Datos 2: Resultado de la segunda solicitud\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "**Operador de propagación**\n\nEl operador de propagación en JavaScript moderno se representa con tres puntos `(...)`. Este operador permite propagar, o expandir, los valores de un arreglo o las propiedades de un objeto en variables o constantes individuales."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let object = { fruit: \"apple\", color: \"green\" };\n\nlet { fruit, color } = { ...object };\n\nconsole.log(`fruit: ${fruit}, color: ${color}`);\n\ncolor = \"red\";\n\nconsole.log(`object.color: ${object.color}, color: ${color}`);\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Es una excelente solución para clonar un arreglo u objeto."
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "let originalArray = [1, 2, 3];\n\nlet clonedArray = [...originalArray];\n\nclonedArray[0] = \"one\";\nclonedArray[1] = \"two\";\nclonedArray[2] = \"three\";\n\nconsole.log(`Arreglo original: ${originalArray}, Arreglo clonado: ${clonedArray}`);\n"
            ],
            "outputs": []
        }
    ]
}